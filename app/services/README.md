📂 文件：app/services/parser.py
📝 功能描述
FrameParser 是项目的协议层（L2 链路层）管理器。它负责处理 32 字节定长物理帧的封装（Wrapping）与拆解（Unwrapping），确保数据在网络传输过程中的完整性与合法性。它是连接底层驱动（Drivers）与上层业务逻辑（Payload）的桥梁。

核心作用
物理帧标准化：将 29 字节的业务载荷（Body）包装成符合硬件接收标准的 32 字节物理帧。

安全性校验：通过包头匹配和校验和（Checksum）验证，自动过滤掉传输过程中的破损包或非法包。

解耦设计：使上层逻辑只需关心 29 字节的内容，无需处理包头和校验细节。

偏移量,长度,字段,说明
0 - 1,2B,Header,固定为 0x55 0xAA
2 - 30,29B,Body,实际业务载荷（由 PayloadBuilder 生成）
31,1B,Checksum,前 31 字节累加和的低 8 位

📖 核心方法说明
1. wrap(body: bytes) -> bytes
功能：将发送端的 29 字节载荷“装箱”。

逻辑：

验证输入是否严格为 29 字节。

在前部拼接 0x55 0xAA。

计算前 31 字节之和并取低 8 位（& 0xFF）作为校验码附加在末尾。

2. unwrap(raw_frame: bytes) -> bytes
功能：将接收到的 32 字节原始帧“拆箱”。

验证流程：

长度检查：必须等于 32 字节。

包头匹配：前两位必须是 0x55 0xAA。

校验和比对：重新计算前 31 字节的和，对比第 32 字节。若不一致则判定为非法帧，返回 None。

输出：验证成功后返回中间的 29 字节 Body 部分。

📂 文件：app/services/payload_builder.py
📝 功能描述
PayloadBuilder 是项目的业务逻辑层（L3 应用层）载荷构建器。它专门负责生成符合协议约定的 29 字节 Body 载荷。该模块将上层的控制意图（如 PID 调优、位置控制、状态查询）转化为标准化的二进制格式，为最终通过 FrameParser 封装成物理帧做准备。

核心作用
指令参数化：将直观的浮点数（Float）和 ID 转换为紧凑的二进制字节流。

读写状态管理：通过控制位（Ctrl）的第一位（Bit 7）自动标识该指令是“写入”操作还是“读取/查询”操作。

定长载荷保障：无论具体的参数量多少，该模块始终通过填充（Padding）技术确保产出的载荷严格为 29 字节，维持协议的稳定性。

📊 载荷结构 (29 Bytes)
每一包由该类生成的载荷都遵循以下严格的内存布局：
偏移量,长度,字段,说明
0,1B,Ctrl,"控制位。Bit 7 为读写位 (1:写, 0:读)；Bit 0-6 为电机 ID。"
1,1B,Type,功能码。决定了后续 24 字节数据区的解析逻辑。
2 - 25,24B,Data,数据区。包含 6 个 float32 型参数。
26 - 28,3B,Reserved,预留位。固定填充 0，用于未来扩展及对齐。

📖 功能常量定义 (Type Code)
通过功能码区分不同的控制逻辑，目前支持以下类型：

TYPE_PID (0x01)：设置或查询电机的 P、I、D、积分限幅等参数。

TYPE_MOTION (0x02)：发送目标位置、目标速度或加速度指令。

TYPE_STATUS (0x04)：主动查询电机的实时位置、电流、速度等反馈数据。

TYPE_SYSTEM (0xFF)：系统级紧急指令，如急停、复位、设置零点。

💡 核心业务方法
1. set_pid(motor_id, p, i, d, ...)
用途：修改指定电机的控制参数。将 6 个 PID 相关的浮点数打包进入数据区。

操作属性：写入（Write）操作。

2. set_target(motor_id, pos, vel, acc)
用途：控制电机运动。只需传入位置等关键参数，缺失参数会自动补 0。

3. query_status(motor_id)
用途：生成查询指令。此时数据区（Data）会全部填充为 0，仅靠 Ctrl 位和 Type 位引导从机回传状态。

📂 文件：app/services/data_processor.py
📝 功能描述
DataProcessor 是项目的业务逻辑层（L3 应用层）解析器。它的作用与 PayloadBuilder 正好相反：它负责将从机（如 ESP32）回传的 29 字节原始载荷 翻译成 Python 开发者易于使用的**结构化字典（Dictionary）**对象。

核心作用
二进制协议翻译：利用 struct.unpack 将无意义的连续字节流转换为具有物理意义的数值（如位置、电流、PID 增益）。

多态分发处理：根据载荷中的 Type 字段自动选择对应的解析逻辑（PID 参数或状态反馈）。

位域信息提取：从单个 Ctrl 字节中分离出电机 ID 以及该包是“写入指令确认”还是“读取数据返回”。

📊 接收载荷结构 (29 Bytes)
偏移量,长度,字段,说明
0,1B,Ctrl,控制位。解析公式：ID = Ctrl & 0x7F；is_write = Ctrl & 0x80。
1,1B,Type,消息类型。决定了后续 24 字节数据段的翻译方式。
2 - 25,24B,Data,数据段。通常包含 6 个 float32 (4字节) 数值。
26 - 28,3B,Reserved,预留位。目前用于对齐。

📖 消息类型解析逻辑
TYPE_PID (0x01)：

数据映射：将 24 字节解析为 p, i, d, i_limit, out_limit, deadzone。

用途：确认电机当前的控制增益参数。

TYPE_STATUS (0x04)：

数据映射：将 24 字节解析为 position, velocity, current, voltage, error_code, state。

用途：实时监控电机的运动状态和健康情况。

未知类型处理：

若收到未定义的功能码，系统会以 hex 格式打印原始载荷，方便开发者进行协议逆向或调试。

💡 核心逻辑细节：位运算提取
在解析 Ctrl 字节时，该模块使用了位掩码技术：

Motor ID: 执行 ctrl & 0x7F，剥离最高位的读写标志，获得 0-127 范围内的电机编号。

读写方向: 执行 ctrl & 0x80。由于从机发回的包通常是对读取指令的响应，因此 is_response 默认为 True。

📂 文件：app/services/comm_handler.py
📝 功能描述
UdpTransceiver 是整个系统的通讯调度中枢。它通过**多线程（Multi-threading）技术，将底层的驱动程序、协议解析器和数据处理器串联在一起，实现了上位机与电机从机之间的全双工（Full-Duplex）**通讯。

核心作用
并发处理：利用后台守护线程实时监听网络数据，确保主程序（如 UI 或控制逻辑）在执行 time.sleep 或复杂计算时不会丢失任何反馈包。

资源整合：作为“胶水层”，自动调用 Parser 进行物理脱壳，调用 DataProcessor 进行业务翻译。

状态寄存器：维护一个线程安全的 latest_data 变量，作为最新的“状态快照”，供主程序随时调取。

端口管理：显式绑定本地监听端口，解决了 UDP 通讯中从机找不到主机地址的常见问题。

🏗 软件架构与数据流
组件,角色,协作关系
WifiCommunicator,搬运工,负责原始字节（bytes）的物理收发。
FrameParser,安检员,负责验证 32 字节帧的完整性与包头。
DataProcessor,翻译官,负责将 29 字节载荷转换为 Python 字典。
UdpTransceiver,调度员,管理线程生命周期，协调上述所有组件。
📖 核心方法说明
1. start()
初始化动作：连接驱动并**绑定（Bind）**本地端口（默认 8081）。绑定动作是确保主机能够接收异步反馈的关键。

线程启动：创建并启动名为 _listen_loop 的后台线程。

守护状态：设置 daemon=True，确保主程序退出时，通讯线程会自动关闭，防止端口占用。

2. _listen_loop() (后台私有方法)
执行频率：循环内包含 1ms 的极短休眠，既能保证毫秒级的响应延迟，又避免了 CPU 空转。

流水线处理：receive -> unwrap -> process -> update latest_data。

异常隔离：内部封装了 try...except，确保即使单次网络包解析出错，监听线程也不会崩溃退出。

3. send_packet(frame: bytes)
安全性：在调用驱动发送前，强制检查物理帧长度是否为 32 字节。

同步调用：由主线程直接调用，实现指令的即时下发。

4. latest_data 与线程锁 (_lock)
竞态保护：由于 latest_data 会被后台线程写入，同时被主线程读取，该类使用了 threading.Lock() 确保数据在读取和更新时的原子性，防止出现内存冲突或读取到残缺数据。